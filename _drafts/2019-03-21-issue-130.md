---
layout: post
title: ! 'Issue #130'
author: btb
sponsor:
    link: https://skafos.ai
    heading: Skafos.ai is Machine Learning for iOS Developers
    body: Skafos is the tool for iOS developers to deploy machine learning to their app. Get started with a pre-trained model, drop in the SDK and then updates are pushed to your app in the background. Sign up for the free beta today.
    displaylink: skafos.ai
---

Last week, Apple [announced](https://developer.apple.com/wwdc19/) this year's
WWDC, while Swift is steadily progressing to what's next after Swift 5.

<!--excerpt-->

{% include sponsor.html %}

### Starter tasks

- [TF-336](https://bugs.swift.org/browse/TF-336) [Python] Add unit testing infrastructure for Python 2 and 3
- [TF-337](https://bugs.swift.org/browse/TF-337) [Python] `PythonObject` conformance to `Sequence` uses array indexing instead of `Python.iter(...)`
- [TF-342](https://bugs.swift.org/browse/TF-342) [Python] Adopt Python iterator C API
- [TF-351](https://bugs.swift.org/browse/TF-351) [AutoDiff] Fixit `.withoutDerivative()` is inserted to the wrong place

### News and community

[Chris Lattner](https://twitter.com/clattner_llvm) and [Brennan Saeta](https://twitter.com/bsaeta) gave [a talk](https://www.youtube.com/watch?v=s65BigoMV_I) on Swift for TensorFlow.

### Commits and pull requests

After about three years, [John Holdsworth](https://twitter.com/Injection4Xcode) 
merged [a pull request](https://github.com/apple/swift/pull/22863)
implementing [SE-0068](https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md): *Expanding Swift `Self` to class members and value types*! 💪

### Accepted proposals

[SE-0242](https://github.com/apple/swift-evolution/blob/master/proposals/0242-default-values-memberwise.md): *Synthesize default values for the memberwise initializer* was [accepted](https://forums.swift.org/t/accepted-se-0242-synthesize-default-values-for-the-memberwise-initializer/21475).

> The proposal is accepted, with a request that the original proposal be amended for clarification of actual behavior. The Core Team felt that the proposal should more explicitly illustrate the actual behavior in a few specific cases, as this was the crux of some of the back-and-forth in the review thread. Note: the proposal has been updated to include more details in the [_proposed solution_](https://github.com/apple/swift-evolution/blob/b5bbc5ae1f53189641951acfd50870f5b886859e/proposals/0242-default-values-memberwise.md#proposed-solution) section, as requested by the Core Team.

### Returned proposals

[SE-0245](https://github.com/apple/swift-evolution/blob/master/proposals/0245-array-uninitialized-initializer.md): *Add an Array Initializer with Access to Uninitialized Storage* was [returned for revision](https://forums.swift.org/t/se-0245-add-an-array-initializer-with-access-to-uninitialized-storage/21469) as (part of) [SE-0223](https://github.com/apple/swift-evolution/blob/master/proposals/0223-array-uninitialized-initializer.md).

> This proposal suggests a new initializer for `Array` and `ContiguousArray`
> that provides access to an array's uninitialized storage buffer.
>
> Some collection operations require working on a fixed-size buffer of uninitialized memory.
> For example, one O(*n*) algorithm for performing a stable partition of an array is as follows:
>
> 1. Create a new array the same size as the original array.
> 2. Iterate over the original array,
>    copying matching elements to the beginning of the new array
>    and non-matching elements to the end.
> 3. When finished iterating, reverse the slice of non-matching elements.
>
> Unfortunately, the standard library provides no way to create an array of a
> particular size without initializing every element. Even if we
> avoid initialization by manually allocating the memory using an
> `UnsafeMutableBufferPointer`, there's no way to convert that buffer into an
> array without copying the contents. There simply isn't a way to implement this
> particular algorithm with maximum efficiency in Swift.

### Proposals in review

[SE-0248](https://github.com/apple/swift-evolution/blob/master/proposals/0248-string-gaps-missing-apis.md): *String Gaps and Missing APIs* is [under review](https://github.com/apple/swift-evolution/blob/master/proposals/0248-string-gaps-missing-apis.md).

> String and related types are missing trivial and obvious functionality, much
> of which currently exists internally but has not been made API. We propose
> adding 9 new methods/properties and 3 new code unit views.
>
> These missing APIs address [commonly encountered](https://forums.swift.org/t/efficiently-retrieving-utf8-from-a-character-in-a-string/19916)
> gaps and [missing functionality](https://bugs.swift.org/browse/SR-9955) for
> users of String and its various types, often leading developers to 
> [reinvent](https://github.com/apple/swift-nio-http2/blob/master/Sources/NIOHPACK/HPACKHeader.swift#L412)
> the same trivial definitions.
>
> We propose:
>
> * 6 simple APIs on Unicode’s various encodings
> * 2 generic initializers for string indices and ranges of indices
> * `Substring.base`, equivalent to `Slice.base`
> * Make `Character.UTF8View` and `Character.UTF16View` public
> * Add `Unicode.Scalar.UTF8View`

[SE-0247](https://github.com/apple/swift-evolution/blob/master/proposals/0247-contiguous-strings.md): *Contiguous Strings* is [under review](https://forums.swift.org/t/se-0247-contiguous-strings/21483).

> One of the most common API requests from performance-minded users of string is a way to get direct access to the raw underlying code units. Now that [Swift 5 uses UTF-8](https://forums.swift.org/t/string-s-abi-and-utf-8/17676) for its preferred encoding, we can provide this.
>
> “Contiguous strings” are strings that are capable of providing a pointer and length to [validly encoded](https://en.wikipedia.org/wiki/UTF-8#Invalid_byte_sequences) UTF-8 contents in constant time. Contiguous strings include:
>
> * All native Swift string forms
> * Lazily bridged Cocoa strings that provide a pointer to contiguous ASCII
> * Any “shared string” concept we may add in the future

[SE-0246](https://github.com/apple/swift-evolution/blob/master/proposals/0246-mathable.md): *Generic Math(s) Functions* is [under review](https://forums.swift.org/t/se-0246-generic-math-s-functions/21479).

> This proposal introduces two new protocols to the standard library: `ElementaryFunctions`
> and `Real`. These protocols combine to provide "basic math functions" in generic contexts
> for floating-point and SIMD types, and provide a path to extend that functionality to
> planned complex types in the future.
>
> `BinaryFloatingPoint` (and the protocols it refines) provides a powerful set of
> abstractions for writing numerical code, but it does not include the transcendental
> operations defined by the C math library, which are instead imported by the platform
> overlay as a set of overloaded concrete free functions.

### Swift Forums

[Doug Gregor](https://twitter.com/dgregor79/) pitched [a proposal](https://forums.swift.org/t/pitch-key-path-member-lookup/21579) around Key Path Member Lookup.

> Dynamic member lookup allows a type to opt in to extending member lookup
> ("dot" syntax) for arbitrary member names, turning them into a string that
> can then be resolved at runtime. Dynamic member lookup allows
> interoperability with dynamic languages where the members of a particular
> instance can only be determined at runtime... but no earlier. Dynamic member
> lookups therefore tend to work with type-erased wrappers around foreign
> language objects (e.g., `PyVal` for an arbitrary Python object), which don't
> provide much static type information.
>
> [We propose to] introduce a new attribute `@keyPathMemberLookup` that can be
> placed on the definition of a type. For such types, "dot" syntax to access a
> member will be rewritten as a use of a special subscript whose argument is a
> key path describing the member.

[Manolo van Ee](https://forums.swift.org/u/orobio/summary) wrote [a post](https://forums.swift.org/t/reverse-generics-and-opaque-result-types/21608) with thoughts on Opaque Result types.

> I've been trying to wrap my head around [SE-0244](https://forums.swift.org/t/se-0244-opaque-result-types/21252): *Opaque Result Types* and
> recently I had some realizations that helped me understand the proposal
> better. I noticed I'm not the only one confused about it, so I thought I'd
> write down some things that might help others to get a better grasp of the
> concept as well.
>
> In doing so, I'd also like to try and rebrand opaque result types, or at
> least the underlying mechanism, to something I'm calling 'reverse generics'.
> I think viewing this all from a slightly different perspective helps a lot
> in understanding the concepts involved.

### Finally

> TODO: something funny/fun. tweet, link, etc.
